<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Ratio Spiral Growth ¬∑ No-gap for all modes</title>
<style>
html,body{margin:0;height:100%;background:#0b1020;color:#e8eefc;font-family:system-ui,Segoe UI,Roboto,sans-serif;overflow:hidden}
canvas{display:block}
#ui{
  position:fixed;left:14px;top:14px;width:580px;
  background:rgba(20,24,40,.82);border:1px solid rgba(255,255,255,.12);
  border-radius:14px;padding:12px;box-shadow:0 10px 30px rgba(0,0,0,.35);
  backdrop-filter:blur(8px);user-select:none;
  transition:transform .2s ease, opacity .2s ease;
}
#ui.minimized{
  transform:translateX(-105%);
  opacity:0;
  pointer-events:none;
}
#ui h3{margin:0 0 8px;font-size:14px;font-weight:650}
.row{display:flex;gap:10px;align-items:center;margin:8px 0}
.row label{flex:1;font-size:12px;opacity:.9}
.row input,.row select{flex:1.4}
.btnrow{display:flex;gap:10px;align-items:center;margin-top:10px;flex-wrap:wrap}
button{
  appearance:none;border:1px solid rgba(255,255,255,.14);
  background:rgba(255,255,255,.08);color:#e8eefc;
  border-radius:12px;padding:8px 10px;cursor:pointer;
  font-size:12px;font-weight:650
}
button:hover{background:rgba(255,255,255,.12)}
button:active{transform:translateY(1px)}
.hint{font-size:11px;opacity:.75;line-height:1.25;margin-top:8px}
.pill{display:inline-block;padding:2px 8px;border-radius:999px;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.10)}
.toggle{
  display:flex;align-items:center;gap:8px;justify-content:flex-start;
  background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.10);
  padding:6px 10px;border-radius:12px
}
.toggle input{transform:scale(1.1)}
small{opacity:.75}
</style>
</head>
<body>
<canvas id="c"></canvas>

<div id="ui">
  <h3>Ratio spiral growth</h3>

  <div class="row">
    <label>Mode</label>
    <select id="mode">
      <option value="silver">Silver: 90¬∞ ¬∑ Œ¥ spiral ¬∑ Œ¥‚Åª¬π iter ¬∑ 8 arms</option>
      <option value="phi72">Phi: 72¬∞ ¬∑ spiral œÜ‚Åª¬π ¬∑ iter œÜ‚Åª¬π ¬∑ 5 arms</option>
      <option value="phi72_s1_i2">Phi: 72¬∞ ¬∑ spiral œÜ‚Åª¬π ¬∑ iter œÜ‚Åª¬≤ ¬∑ 5 arms</option>
      <option value="phi108">Phi: 108¬∞ ¬∑ spiral œÜ‚Åª¬π ¬∑ iter œÜ‚Åª¬π ¬∑ 5 arms</option>
      <option value="phi90_4">Phi: 90¬∞ ¬∑ spiral œÜ‚Åª¬π ¬∑ iter œÜ‚Åª¬π ¬∑ 4 arms</option>
      <option value="rat60_23_13">60¬∞ ¬∑ spiral (2/3) ¬∑ iter (1/3) ¬∑ 6 arms</option>
    </select>
  </div>

  <div class="row">
    <label>Iterations</label>
    <input id="iters" type="range" min="0" max="8" step="1" value="2">
  </div>

  <div class="row">
    <label>Line width</label>
    <input id="lw" type="range" min="0.4" max="4" step="0.1" value="1.6">
  </div>

  <div class="row">
    <label>Color</label>
    <div class="toggle" style="flex:1.4">
      <input id="rainbow" type="checkbox" />
      <span style="font-size:12px;opacity:.92">Rainbow by iteration</span>
    </div>
  </div>

  <div class="row">
    <label>Brightness</label>
    <input id="bright" type="range" min="0.15" max="2.5" step="0.01" value="1.00">
  </div>

  <div class="row">
    <label>Quality</label>
    <select id="quality">
      <option value="low">Low (fast)</option>
      <option value="med" selected>Medium</option>
      <option value="high">High (slower)</option>
    </select>
  </div>

  <div class="btnrow">
    <button id="saveBtn">Save PNG</button>
    <button id="fitBtn">Fit to Screen</button>
  </div>

  <div class="hint">
    <span class="pill">Wheel</span> zoom ‚Ä¢
    <span class="pill">Drag</span> pan ‚Ä¢
    <span class="pill">M</span> toggle menu<br>
    ‚úÖ No-gap attach for ALL modes: <span class="pill">P‚Ä≤ = A + (-s)(P ‚àí A)</span><br>
    ‚úÖ N=5 auto-level keeps neighboring 2nd-iteration centers horizontal
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });

  const PHI   = (1 + Math.sqrt(5)) / 2;
  const DELTA = 1 + Math.SQRT2;

  const uiEl = document.getElementById('ui');
  const modeEl = document.getElementById('mode');
  const itersEl = document.getElementById('iters');
  const lwEl = document.getElementById('lw');
  const rainbowEl = document.getElementById('rainbow');
  const brightEl = document.getElementById('bright');
  const qualityEl = document.getElementById('quality');
  const saveBtn = document.getElementById('saveBtn');
  const fitBtn = document.getElementById('fitBtn');

  let scale = 1.35, panX = 0, panY = 0;
  let dragging = false, lastX = 0, lastY = 0;

  let needsNewRender = true;
  let renderToken = 0;

  const baseCache = new Map();
  const BASE_R0 = 18;

  // last computed world-space bounds (for Fit to Screen)
  let lastBBox = null;

  // üîë Toggle menu with "M"
  let menuMinimized = false;
  window.addEventListener('keydown', e => {
    if (e.key === 'm' || e.key === 'M') {
      menuMinimized = !menuMinimized;
      uiEl.classList.toggle('minimized', menuMinimized);
    }
  });

  function resize(){
    const dpr = devicePixelRatio || 1;
    canvas.width = Math.floor(innerWidth * dpr);
    canvas.height = Math.floor(innerHeight * dpr);
    canvas.style.width = innerWidth + 'px';
    canvas.style.height = innerHeight + 'px';
    if (!panX && !panY) { panX = innerWidth/2; panY = innerHeight/2; }
    scheduleRender();
  }
  addEventListener('resize', resize);

  function screenToWorld(x,y){ return [(x-panX)/scale, (y-panY)/scale]; }

  canvas.addEventListener('wheel', e => {
    e.preventDefault();
    const [wx, wy] = screenToWorld(e.clientX, e.clientY);
    scale = Math.min(350, Math.max(0.0015, scale * Math.pow(1.002, -e.deltaY)));
    panX = e.clientX - wx*scale;
    panY = e.clientY - wy*scale;
    scheduleRender();
  }, { passive:false });

  canvas.addEventListener('pointerdown', e => {
    dragging = true; lastX = e.clientX; lastY = e.clientY;
    canvas.setPointerCapture(e.pointerId);
  });
  canvas.addEventListener('pointermove', e => {
    if (!dragging) return;
    panX += e.clientX - lastX;
    panY += e.clientY - lastY;
    lastX = e.clientX; lastY = e.clientY;
    scheduleRender();
  });
  canvas.addEventListener('pointerup', ()=> dragging=false);
  canvas.addEventListener('pointercancel', ()=> dragging=false);

  function clear(){
    const dpr = devicePixelRatio || 1;
    ctx.setTransform(1,0,0,1,0,0);
    ctx.fillStyle = '#0b1020';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }

  function rOfTheta(t, r0, segAngle, ratio){
    return r0 * Math.exp(Math.log(ratio) * (t / segAngle));
  }

  function endpointLocal(N, k, endTheta, rEnd, rotOffset){
    const ang = endTheta + rotOffset + k * (2*Math.PI/N);
    return [rEnd*Math.cos(ang), rEnd*Math.sin(ang)];
  }

  function getParams(){
    const mode = modeEl.value;

    let N, segAngle, spiralRatio, segCount, totalTheta, childScale;

    if (mode === 'silver'){
      N = 8;
      segAngle = Math.PI/2;
      spiralRatio = DELTA;
      segCount = 8;
      totalTheta = segCount * segAngle;
      childScale = 1/DELTA;
    } else if (mode === 'phi72'){
      N = 5;
      segAngle = 2*Math.PI/5;
      spiralRatio = 1/PHI;
      segCount = 7;
      totalTheta = -segCount * segAngle;
      childScale = 1/PHI;
    } else if (mode === 'phi72_s1_i2'){
      N = 5;
      segAngle = 2*Math.PI/5;
      spiralRatio = 1/PHI;
      segCount = 7;
      totalTheta = -segCount * segAngle;
      childScale = 1/(PHI*PHI);
    } else if (mode === 'phi108'){
      N = 5;
      segAngle = 3*Math.PI/5;
      spiralRatio = 1/PHI;
      segCount = 7;
      totalTheta = -segCount * segAngle;
      childScale = 1/PHI;
    } else if (mode === 'phi90_4'){
      N = 4;
      segAngle = Math.PI/2;
      spiralRatio = 1/PHI;
      segCount = 10;
      totalTheta = -segCount * segAngle;
      childScale = 1/PHI;
    } else { // rat60_23_13
      N = 6;
      segAngle = Math.PI/3;
      spiralRatio = 2/3;
      segCount = 9;
      totalTheta = -segCount * segAngle;
      childScale = 1/3;
    }

    // Auto-level only for N=5: force neighboring 2nd-iteration centers horizontal
    let rotOffset = 0;
    if (N === 5) {
      const endTheta = totalTheta;
      const rEnd1 = Math.exp(Math.log(spiralRatio) * (endTheta / segAngle));

      const kA = 0, kB = 1;
      const angA = endTheta + kA * (2*Math.PI/N);
      const angB = endTheta + kB * (2*Math.PI/N);

      const ax = rEnd1 * Math.cos(angA), ay = rEnd1 * Math.sin(angA);
      const bx = rEnd1 * Math.cos(angB), by = rEnd1 * Math.sin(angB);

      const s = childScale;
      const f = (1 - s*s);

      const c2Ax = f * ax, c2Ay = f * ay;
      const c2Bx = f * bx, c2By = f * by;

      rotOffset = -Math.atan2(c2By - c2Ay, c2Bx - c2Ax);
    }

    const quality = qualityEl.value;
    const basePtsPerSeg = (quality === 'low') ? 70 : (quality === 'high' ? 160 : 110);

    return { mode, N, segAngle, spiralRatio, segCount, totalTheta, childScale, rotOffset, basePtsPerSeg };
  }

  function getBasePolylines(params){
    const { mode, N, segAngle, spiralRatio, segCount, totalTheta, rotOffset, basePtsPerSeg } = params;
    const key = `${mode}|N${N}|off${rotOffset.toFixed(6)}|A${segAngle.toFixed(6)}|R${spiralRatio.toFixed(10)}|S${segCount}|T${totalTheta.toFixed(6)}|Q${basePtsPerSeg}`;

    const cached = baseCache.get(key);
    if (cached) return cached;

    const steps = Math.max(160, Math.floor((Math.abs(totalTheta)/segAngle) * basePtsPerSeg));
    const arms = [];

    for (let k=0;k<N;k++){
      const rot = rotOffset + k*(2*Math.PI/N);
      const arr = new Float32Array((steps+1)*2);
      for (let i=0;i<=steps;i++){
        const t = (i/steps) * totalTheta;
        const theta = t + rot;
        const r = rOfTheta(t, 1, segAngle, spiralRatio);
        arr[i*2+0] = r * Math.cos(theta);
        arr[i*2+1] = r * Math.sin(theta);
      }
      arms.push(arr);
    }

    const out = { arms, steps, key };
    baseCache.set(key, out);
    return out;
  }

  function clamp01(x){ return Math.max(0, Math.min(1, x)); }

  function strokeForDepth(dep, maxDepth, baseAlpha, rainbow, brightness){
    const alpha = clamp01(baseAlpha * brightness);
    if (!rainbow) return `rgba(180,210,255,${alpha})`;

    const t = (maxDepth <= 0) ? 0 : dep / maxDepth;
    const hue = (360 * t) % 360;
    const L = Math.max(35, Math.min(78, 65 + (brightness - 1) * 8));
    return `hsla(${hue.toFixed(2)}, 95%, ${L.toFixed(1)}%, ${alpha})`;
  }

  function bboxInit(){
    return { minX: +Infinity, minY: +Infinity, maxX: -Infinity, maxY: -Infinity };
  }
  function bboxExpand(b, x, y){
    if (x < b.minX) b.minX = x;
    if (y < b.minY) b.minY = y;
    if (x > b.maxX) b.maxX = x;
    if (y > b.maxY) b.maxY = y;
  }

  // Node affine: world = M*[x,y] + C ; M=(a b; c d), C=(cx,cy)
  function drawPolyline(polyXY, r0, node, dep, maxDepth, baseAlpha, rainbow, brightness, bbox){
    const { a,b,c,d, cx,cy } = node;
    ctx.strokeStyle = strokeForDepth(dep, maxDepth, baseAlpha, rainbow, brightness);
    ctx.beginPath();

    const sampleStep = Math.max(2, Math.floor((polyXY.length/2) / 140));

    for (let i=0, p=0;i<polyXY.length;i+=2, p++){
      const x0 = polyXY[i]   * r0;
      const y0 = polyXY[i+1] * r0;
      const x = a*x0 + b*y0 + cx;
      const y = c*x0 + d*y0 + cy;

      const sx = x*scale + panX;
      const sy = y*scale + panY;

      if (i===0) ctx.moveTo(sx,sy);
      else ctx.lineTo(sx,sy);

      if (bbox && (p % sampleStep === 0 || i === polyXY.length-2)) bboxExpand(bbox, x, y);
    }
    ctx.stroke();
  }

  function scheduleRender(){
    needsNewRender = true;
    requestAnimationFrame(renderFrame);
  }

  function renderFrame(){
    if (!needsNewRender) return;
    needsNewRender = false;

    const token = ++renderToken;

    clear();
    ctx.lineWidth = +lwEl.value;
    ctx.lineCap = ctx.lineJoin = 'round';

    const depthUI = +itersEl.value;
    const r0 = BASE_R0;
    const rainbow = !!rainbowEl.checked;
    const brightness = +brightEl.value;

    const params = getParams();
    const { mode, N, segAngle, spiralRatio, totalTheta, childScale, rotOffset } = params;

    const maxDepthPractical = (mode === 'phi72_s1_i2') ? 7 : 8;
    const depthMax = Math.min(depthUI, maxDepthPractical);

    const base = getBasePolylines(params);

    const endTheta = totalTheta;
    const rEnd1 = rOfTheta(endTheta, 1, segAngle, spiralRatio);

    const budgetNodesPerFrame = (qualityEl.value === 'low') ? 18 : (qualityEl.value === 'high' ? 7 : 11);

    const stack = [{ a:1,b:0,c:0,d:1, cx:0,cy:0, depth:0 }];

    const bbox = bboxInit();

    function step(){
      if (token !== renderToken) return;

      let n = 0;
      while (stack.length && n < budgetNodesPerFrame){
        const node = stack.pop();
        const dep = node.depth;

        const baseAlpha = Math.max(0.02, 0.22 * Math.pow(0.72, dep));

        for (let k=0;k<N;k++){
          drawPolyline(base.arms[k], r0, node, dep, depthMax, baseAlpha, rainbow, brightness, bbox);
        }

        if (dep < depthMax){
          // No-gap attach for ALL modes: P‚Ä≤ = A + (-s)(P ‚àí A)
          const s = childScale;
          const negs = -s;

          for (let k=0;k<N;k++){
            const [ax1, ay1] = endpointLocal(N, k, endTheta, rEnd1, rotOffset);
            const Ax0 = ax1 * r0, Ay0 = ay1 * r0;

            // A in world
            const Ax = node.a*Ax0 + node.b*Ay0 + node.cx;
            const Ay = node.c*Ax0 + node.d*Ay0 + node.cy;

            // M' = (-s)M
            const a2 = negs * node.a, b2 = negs * node.b;
            const c2 = negs * node.c, d2 = negs * node.d;

            // C' = (-s)C + (1+s)A
            const cx2 = negs * node.cx + (1 + s) * Ax;
            const cy2 = negs * node.cy + (1 + s) * Ay;

            stack.push({ a:a2,b:b2,c:c2,d:d2, cx:cx2,cy:cy2, depth: dep+1 });
          }
        }

        n++;
      }

      if (stack.length) {
        requestAnimationFrame(step);
      } else {
        if (bbox.minX !== Infinity) lastBBox = bbox;
      }
    }

    requestAnimationFrame(step);
  }

  function fitToScreen(){
    if (!lastBBox) return;

    const W = innerWidth;
    const H = innerHeight;

    const boxH = Math.max(1e-9, lastBBox.maxY - lastBBox.minY);

    // snug top/bottom with a tiny safety margin (2%)
    const margin = 0.98;
    const newScale = (H * margin) / boxH;

    scale = Math.min(350, Math.max(0.0015, newScale));

    const cx = (lastBBox.minX + lastBBox.maxX) / 2;
    const cy = (lastBBox.minY + lastBBox.maxY) / 2;

    panX = W/2 - cx * scale;
    panY = H/2 - cy * scale;

    scheduleRender();
  }

  function savePNG(){
    const link = document.createElement('a');
    const stamp = new Date().toISOString().replace(/[:.]/g,'-');
    link.download = `ratio-spiral-${modeEl.value}-iter-${itersEl.value}-${stamp}.png`;
    link.href = canvas.toDataURL('image/png');
    link.click();
  }

  const onAnyChange = () => scheduleRender();
  modeEl.addEventListener('change', () => {
    if (modeEl.value !== 'silver' && +itersEl.value > 7) itersEl.value = 7;
    scheduleRender();
  });
  itersEl.addEventListener('input', onAnyChange);
  lwEl.addEventListener('input', onAnyChange);
  rainbowEl.addEventListener('change', onAnyChange);
  brightEl.addEventListener('input', onAnyChange);
  qualityEl.addEventListener('change', onAnyChange);

  saveBtn.addEventListener('click', savePNG);
  fitBtn.addEventListener('click', fitToScreen);

  resize();
})();
</script>
</body>
</html>
